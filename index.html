<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Table Tennis League</title>
    
    <!-- PWA Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TT League">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0A0E27">
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlRhYmxlIFRlbm5pcyBMZWFndWUiLAogICJzaG9ydF9uYW1lIjogIlRUIExlYWd1ZSIsCiAgInN0YXJ0X3VybCI6ICIuLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzBBMEUyNyIsCiAgInRoZW1lX2NvbG9yIjogIiNGRjZCMzUiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXhNVElpSUdobGFXZG9kRDBpTVRFeUlqNDhjbVZqZENCM2FXUjBhRDBpTVRFeUlpQm9aV2xuYUhROUlqRXhNaUlnWm1sc2JEMGlJekJCTUVVeU55SXZQangwWlhoMElIZzlJalUySWlCNVBTSTFOaUlnWm05dWRDMW1ZVzFwYkhrOUlrSmxZbUZ6SURSbGRXVWlJR1pwYkd3OUlpTkdSamRDTXpVaUlHWnZiblF0YzJsNlpUMGlNelppSUhSbGVIUXRZVzVqYUc5eVBTSnRhV1JrYkdVaVBsUlVQQzkwWlhoMFBqd3ZjM1puUGc9PSIsCiAgICAgICJzaXplcyI6ICIxMTJ4MTEyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l4T1RJaUlHaGxhV2RvZEQwaU1Ua3lJajQ4Y21WamRDQjNhV1IwYUQwaU1Ua3lJaUJvWldsbmFIUTlJakU1TWlJZ1ptbHNiRDBpSXpCQk1FVXlOeUl2UGp4MFpYaDBJSGc5SWprMklpQjVQU0k1TmlJZ1ptOXVkQzFtWVcxcGJIazlJa0psWW1GeklEUmxkV1VpSUdacGJHdzlJaU5HUmpkQ016VWlJR1p2Ym5RdGMybDZaVDBpTmpRaUlIUmxlSFF0WVc1amFHOXlQU0p0YVdSa2JHVWlQbFJVUEM5MFpYaDBQand2YzNablBnPT0iLAogICAgICAic2l6ZXMiOiAiMTkyeDE5MiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiCiAgICB9CiAgXQp9">
    
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Work+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #FF6B35;
            --secondary: #004E89;
            --accent: #F7B801;
            --team1: #2A9D8F;
            --team2: #E76F51;
            --bg: #0A0E27;
            --surface: #1A1F3A;
            --text: #E8E9F3;
            --text-dim: #9CA3AF;
            --border: #2D3561;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Work Sans', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(255, 107, 53, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 78, 137, 0.1) 0%, transparent 50%);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1.5rem 0;
        }

        h1 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(2.5rem, 8vw, 4rem);
            letter-spacing: 0.1em;
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: clamp(0.8rem, 2vw, 1.1rem);
            text-transform: uppercase;
            letter-spacing: 0.3em;
        }

        .edit-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-family: 'Work Sans', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: #ff5722;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 107, 53, 0.4);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--primary);
        }

        .edit-status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgb(34, 197, 94);
            border-radius: 8px;
            color: rgb(34, 197, 94);
            font-weight: 600;
            font-size: 0.9rem;
        }

        .sync-status {
            font-size: 0.85rem;
            color: var(--text-dim);
            text-align: center;
            margin-top: 0.5rem;
        }

        .tabs {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: var(--surface);
            border: 2px solid var(--border);
            color: var(--text);
            font-family: 'Work Sans', sans-serif;
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
        }

        .tab.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 107, 53, 0.4);
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .card {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .card-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .fixtures-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .match-card {
            background: linear-gradient(135deg, var(--surface) 0%, rgba(26, 31, 58, 0.6) 100%);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            transition: all 0.3s ease;
        }

        .match-card.completed {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.25) 0%, rgba(42, 157, 143, 0.3) 100%);
            border-color: rgb(34, 197, 94);
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.3);
        }

        .match-card.invalid {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.25) 0%, rgba(220, 38, 38, 0.3) 100%);
            border-color: rgb(239, 68, 68);
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.3);
        }

        .match-card:hover {
            border-color: var(--accent);
            transform: scale(1.02);
        }

        .invalid-badge {
            text-align: center;
            margin-top: 0.75rem;
            font-weight: 700;
            font-size: 0.85rem;
            color: rgb(239, 68, 68);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .round-badge {
            display: inline-block;
            background: var(--secondary);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
        }

        .match-players {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 0.75rem;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .player-info {
            text-align: left;
        }

        .player-info.away {
            text-align: right;
        }

        .player-name {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 0.25rem;
        }

        .player-team {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .vs {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            color: var(--accent);
        }

        .score-inputs {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 0.5rem;
            align-items: center;
        }

        .score-input {
            background: var(--bg);
            border: 2px solid var(--border);
            color: var(--text);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 1.1rem;
            font-weight: 700;
            text-align: center;
            font-family: 'Work Sans', sans-serif;
            transition: all 0.3s ease;
            width: 100%;
        }

        .score-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.2);
        }

        .score-input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .winner-badge {
            text-align: center;
            margin-top: 0.75rem;
            font-weight: 700;
            font-size: 0.85rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--surface);
            border-radius: 8px;
            overflow: hidden;
        }

        thead {
            background: linear-gradient(135deg, var(--secondary) 0%, rgba(0, 78, 137, 0.8) 100%);
        }

        th {
            padding: 0.75rem 0.5rem;
            text-align: left;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            color: white;
        }

        th.center, td.center {
            text-align: center;
        }

        tbody tr {
            border-bottom: 1px solid var(--border);
            transition: all 0.2s ease;
        }

        tbody tr:hover {
            background: rgba(255, 107, 53, 0.1);
        }

        td {
            padding: 0.75rem 0.5rem;
            font-size: 0.85rem;
        }

        .pos {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .player-cell {
            font-weight: 600;
        }

        .team-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            white-space: nowrap;
        }

        .team1 {
            background: rgba(42, 157, 143, 0.2);
            color: var(--team1);
            border: 1px solid var(--team1);
        }

        .team2 {
            background: rgba(231, 111, 81, 0.2);
            color: var(--team2);
            border: 1px solid var(--team2);
        }

        .stat-highlight {
            font-weight: 700;
            color: var(--accent);
        }

        .positive {
            color: var(--team1);
        }

        .negative {
            color: var(--team2);
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--text-dim);
            font-size: 1.2rem;
        }

        .clickable-player {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .clickable-player:hover {
            color: var(--primary);
            text-decoration: underline;
        }

        .player-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .player-modal.active {
            display: flex;
        }

        .player-modal-content {
            background: var(--surface);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-close {
            float: right;
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 2rem;
            height: 2rem;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--primary);
        }

        .form-indicator {
            display: inline-flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .form-dot {
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.85rem;
        }

        .form-dot.win {
            background: rgba(34, 197, 94, 0.3);
            border: 2px solid rgb(34, 197, 94);
            color: rgb(34, 197, 94);
        }

        .form-dot.loss {
            background: rgba(239, 68, 68, 0.3);
            border: 2px solid rgb(239, 68, 68);
            color: rgb(239, 68, 68);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 2rem;
            max-width: 400px;
            width: 100%;
        }

        .modal-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            color: var(--primary);
            margin-bottom: 1rem;
        }

        .input {
            width: 100%;
            background: var(--bg);
            border: 2px solid var(--border);
            color: var(--text);
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 1rem;
            font-family: 'Work Sans', sans-serif;
            margin-bottom: 1rem;
        }

        .input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.2);
        }

        .modal-buttons {
            display: flex;
            gap: 0.75rem;
        }

        .info-text {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-top: 1rem;
            padding: 0.75rem;
            background: rgba(247, 184, 1, 0.1);
            border-left: 3px solid var(--accent);
            border-radius: 4px;
        }

        .table-responsive {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
            }

            .card {
                padding: 1rem;
            }

            .fixtures-grid {
                grid-template-columns: 1fr;
            }

            th, td {
                padding: 0.5rem 0.25rem;
                font-size: 0.75rem;
            }

            .pos {
                font-size: 1.2rem;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>TABLE TENNIS LEAGUE</h1>
            <div class="subtitle" id="seasonSubtitle">Season 2026</div>
            
            <div class="edit-controls">
                <button id="editBtn" class="btn btn-primary" onclick="showPasswordModal()">
                    üîí Enable Edit Mode
                </button>
                <div id="editStatus" style="display: none;" class="edit-status">
                    ‚úì Edit Mode Active
                    <button class="btn btn-secondary" style="padding: 0.25rem 0.75rem; font-size: 0.8rem;" onclick="disableEditMode()">Lock</button>
                </div>
            </div>
            <div class="sync-status" id="syncStatus">Loading...</div>
            <div id="lastUpdated" style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.25rem;"></div>
        </header>

        <div class="tabs">
            <button class="tab active" onclick="showSection('fixtures', this)">Fixtures</button>
            <button class="tab" onclick="showSection('individual', this)">Individual League</button>
            <button class="tab" onclick="showSection('team', this)">Team League</button>
            <button class="tab" onclick="showSection('headtohead', this)">Head-to-Head</button>
            <button class="tab" onclick="showSection('rules', this)">Rules</button>
            <button class="tab" onclick="showSection('admin', this)">üîß Admin Tools</button>
        </div>

        <!-- Fixtures Section -->
        <div id="fixtures" class="section active">
            <div style="display: flex; justify-content: center; gap: 0.75rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
                <button class="tab active" id="filter-all" onclick="setFixtureFilter('all')">All Matches</button>
                <button class="tab" id="filter-pending" onclick="setFixtureFilter('pending')">Pending Only</button>
                <button class="tab" id="filter-completed" onclick="setFixtureFilter('completed')">Completed Only</button>
            </div>
            <div id="fixturesContent"></div>
        </div>

        <!-- Individual League Section -->
        <div id="individual" class="section">
            <div class="card">
                <div class="card-title">Individual Standings</div>
                <div class="table-responsive">
                    <table>
                        <thead>
                            <tr>
                                <th class="center">Pos</th>
                                <th>Player</th>
                                <th>Team</th>
                                <th class="center">P</th>
                                <th class="center">W</th>
                                <th class="center">L</th>
                                <th class="center">W-N</th>
                                <th class="center">PF</th>
                                <th class="center">PA</th>
                                <th class="center">Diff</th>
                                <th class="center">Pts</th>
                            </tr>
                        </thead>
                        <tbody id="individual-table"></tbody>
                    </table>
                </div>
                <div class="info-text">
                    <strong>W-N</strong> = Win to Nil (11-0 victories, worth 2 points each)
                </div>
            </div>
        </div>

        <!-- Team League Section -->
        <div id="team" class="section">
            <div class="card">
                <div class="card-title">Team Standings</div>
                <div class="table-responsive">
                    <table>
                        <thead>
                            <tr>
                                <th class="center">Pos</th>
                                <th>Team</th>
                                <th>Players</th>
                                <th class="center">P</th>
                                <th class="center">W</th>
                                <th class="center">L</th>
                                <th class="center">W-N</th>
                                <th class="center">PF</th>
                                <th class="center">PA</th>
                                <th class="center">Diff</th>
                                <th class="center">Pts</th>
                            </tr>
                        </thead>
                        <tbody id="team-table"></tbody>
                    </table>
                </div>
                <div class="info-text">
                    <strong>Note:</strong> Team points = 1 point per win (even for 11-0 victories)
                </div>
            </div>
        </div>

        <!-- Head-to-Head Section -->
        <div id="headtohead" class="section">
            <div class="card">
                <div class="card-title">Head-to-Head Records</div>
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Select Player:</label>
                    <select id="h2h-player-select" onchange="renderHeadToHead()" style="width: 100%; max-width: 300px; background: var(--bg); border: 2px solid var(--border); color: var(--text); padding: 0.75rem; border-radius: 8px; font-size: 1rem; font-family: 'Work Sans', sans-serif;">
                        <option value="">-- Choose a player --</option>
                    </select>
                </div>
                <div id="h2h-content"></div>
            </div>
        </div>

        <!-- Rules Section -->
        <div id="rules" class="section">
            <div class="card">
                <div class="card-title">League Rules</div>
                
                <h3 style="color: var(--primary); font-size: 1.3rem; margin: 1.5rem 0 1rem 0; font-weight: 700;">Scoring Rules</h3>
                
                <div style="background: rgba(255, 107, 53, 0.1); border-left: 4px solid var(--primary); padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
                    <div style="margin-bottom: 0.75rem;">
                        <strong style="color: var(--accent);">1)</strong> For games that go past 11 points, the final score will be recorded as <strong>11-10</strong> to the winner.
                    </div>
                    <div style="margin-bottom: 0.75rem;">
                        <strong style="color: var(--accent);">2)</strong> 11-0 victories give the winning player <strong>2 points</strong> on the individual table but only <strong>1 point</strong> on the team table.
                    </div>
                    <div>
                        <strong style="color: var(--accent);">3)</strong> League position will be determined by, in order of priority:
                        <ul style="margin-left: 2rem; margin-top: 0.5rem;">
                            <li><strong>Points</strong> (highest first)</li>
                            <li><strong>Points Difference</strong> (highest first)</li>
                            <li><strong>Points For</strong> (highest first)</li>
                            <li><strong>Wins to Nil</strong> (highest first)</li>
                            <li><strong>Player/Team Name</strong> (alphabetically)</li>
                        </ul>
                    </div>
                </div>

                <h3 style="color: var(--primary); font-size: 1.3rem; margin: 2rem 0 1rem 0; font-weight: 700;">Match Format</h3>
                
                <div style="background: rgba(0, 78, 137, 0.1); border-left: 4px solid var(--secondary); padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
                    <div style="margin-bottom: 0.75rem;">
                        <strong style="color: var(--accent);">Home vs Away:</strong> The player listed on the <strong>left</strong> is the home player, and the player on the <strong>right</strong> is the away player.
                    </div>
                    <div style="margin-bottom: 0.75rem;">
                        <strong style="color: var(--accent);">Rounds:</strong> The league consists of 4 rounds. Each player plays every other player once per round.
                    </div>
                    <div>
                        <strong style="color: var(--accent);">Home/Away Balance:</strong> Each pair of players will play 4 times total - 2 home games for each player.
                    </div>
                </div>

                <h3 style="color: var(--primary); font-size: 1.3rem; margin: 2rem 0 1rem 0; font-weight: 700;">Abbreviations</h3>
                
                <div style="background: rgba(247, 184, 1, 0.1); border-left: 4px solid var(--accent); padding: 1rem; border-radius: 4px;">
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 0.5rem 1rem; align-items: start;">
                        <strong>P:</strong> <span>Played</span>
                        <strong>W:</strong> <span>Won</span>
                        <strong>L:</strong> <span>Lost</span>
                        <strong>W-N:</strong> <span>Win to Nil (11-0 victories)</span>
                        <strong>PF:</strong> <span>Points For</span>
                        <strong>PA:</strong> <span>Points Against</span>
                        <strong>Diff:</strong> <span>Points Difference (PF - PA)</span>
                        <strong>Pts:</strong> <span>Total Points</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Admin Tools Section -->
        <div id="admin" class="section">
            <div id="adminLocked" class="card">
                <div class="card-title">üîß Admin Tools</div>
                <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid rgb(239, 68, 68); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                    <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 0.5rem; color: rgb(239, 68, 68);">‚ö†Ô∏è Admin Access Required</div>
                    <div style="margin-bottom: 1rem;">This area contains powerful tools that can modify or delete league data. Admin password required.</div>
                </div>
                <div style="max-width: 400px;">
                    <input type="password" id="adminPasswordInput" class="input" placeholder="Enter admin password" onkeypress="if(event.key==='Enter') unlockAdmin()" style="margin-bottom: 1rem;">
                    <button class="btn btn-primary" onclick="unlockAdmin()">Unlock Admin Tools</button>
                </div>
            </div>

            <div id="adminUnlocked" style="display: none;">
                <div class="card">
                    <div class="card-title">üîß Admin Tools</div>
                    <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid rgb(239, 68, 68); padding: 1rem; border-radius: 8px; margin-bottom: 2rem;">
                        <strong>‚ö†Ô∏è Warning:</strong> Actions in this area can permanently modify or delete data. Use with caution.
                    </div>

                    <!-- Backup & Export -->
                    <h3 style="color: var(--primary); font-size: 1.5rem; margin-bottom: 1rem;">üì¶ Backup & Export</h3>
                    <div style="display: grid; gap: 1rem; margin-bottom: 2rem;">
                        <button class="btn" style="background: rgb(34, 197, 94); color: white;" onclick="exportBackup()">
                            üíæ Export Current Season (JSON Backup)
                        </button>
                        <div class="info-text">
                            Download complete league data as JSON file. Can be restored by uploading to JSONBin if needed.
                        </div>
                    </div>

                    <!-- Season Management -->
                    <h3 style="color: var(--primary); font-size: 1.5rem; margin-bottom: 1rem;">üèÜ Season Management</h3>
                    <div style="display: grid; gap: 1rem; margin-bottom: 2rem;">
                        <button class="btn" style="background: rgb(139, 92, 246); color: white;" onclick="showArchiveModal()">
                            üìÅ Archive Current Season
                        </button>
                        <button class="btn" style="background: rgb(59, 130, 246); color: white;" onclick="showNewSeasonModal()">
                            ‚ú® Start New Season
                        </button>
                        <button class="btn" style="background: rgb(245, 158, 11); color: white;" onclick="resetCurrentSeason()">
                            üîÑ Reset Current Season (Clear Scores Only)
                        </button>
                    </div>

                    <!-- Archived Seasons -->
                    <h3 style="color: var(--primary); font-size: 1.5rem; margin-bottom: 1rem;">üìö Archived Seasons</h3>
                    <div id="archivedSeasonsList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Password Modal -->
    <div id="passwordModal" class="modal" onclick="if(event.target===this)hidePasswordModal()">
        <div class="modal-content">
            <div class="modal-title">Enter Password</div>
            <input 
                type="password" 
                id="passwordInput" 
                class="input" 
                placeholder="Enter password"
                onkeypress="if(event.key==='Enter') submitPassword()"
            />
            <div class="modal-buttons">
                <button class="btn btn-primary" style="flex: 1;" onclick="submitPassword()">Submit</button>
                <button class="btn btn-secondary" style="flex: 1;" onclick="hidePasswordModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Player Stats Modal -->
    <div id="playerModal" class="player-modal" onclick="if(event.target===this)closePlayerModal()">
        <div class="player-modal-content">
            <button class="modal-close" onclick="closePlayerModal()">√ó</button>
            <div id="playerModalContent"></div>
        </div>
    </div>

    <!-- Archive Viewer Modal -->
    <div id="archiveModal" class="player-modal" onclick="if(event.target===this)closeArchiveModal()">
        <div class="player-modal-content" style="max-width: 750px;">
            <button class="modal-close" onclick="closeArchiveModal()">√ó</button>
            <div id="archiveModalContent"></div>
        </div>
    </div>

    <script>
        // IMPORTANT: Replace YOUR_BIN_ID with actual bin ID after creating it
        // Visit https://jsonbin.io to create a free account and bin
        const BIN_ID = '69805bcdd0ea881f409a838b';
        const API_KEY = '$2a$10$jMnetQRCB4g0muo8f9o.HuT3pPVCaWwTunQeT9f2OzDrhD0zABr7e';
        const EDIT_PASSWORD = 'cumback';
        const ADMIN_PASSWORD = '15873';

        let players = {
            'A': { name: 'Phil', team: 'Team 1' },
            'B': { name: 'Adam', team: 'Team 1' },
            'C': { name: 'Alex', team: 'Team 1' },
            'D': { name: 'Martin', team: 'Team 1' },
            'E': { name: 'Maibu', team: 'Team 2' },
            'F': { name: 'Tom', team: 'Team 2' },
            'G': { name: 'Ryan', team: 'Team 2' },
            'H': { name: 'Aaron', team: 'Team 2' }
        };

        let teams = {
            'Team 1': { name: 'Site Services', players: ['A', 'B', 'C', 'D'] },
            'Team 2': { name: 'Machining Maint', players: ['E', 'F', 'G', 'H'] }
        };

        let fixtures = null;
        let isEditMode = false;
        let fixtureFilter = 'all'; // 'all', 'pending', 'completed'
        let lastUpdateTime = Date.now();
        let autoRefreshInterval = null;
        let isAdminMode = false;
        let saveTimeout = null;
        let archivedSeasons = [];
        let currentSeasonName = 'Season 2026';

        // For demo purposes, use localStorage until BIN_ID is configured
        const USE_LOCAL_STORAGE = BIN_ID === 'YOUR_BIN_ID';

        function generateFixtures() {
            const allMatchups = [];
            const playerCodes = Object.keys(players);
            
            for (let i = 0; i < playerCodes.length; i++) {
                for (let j = i + 1; j < playerCodes.length; j++) {
                    allMatchups.push([playerCodes[i], playerCodes[j]]);
                }
            }

            const newFixtures = { 1: [], 2: [], 3: [], 4: [] };
            
            allMatchups.forEach(([p1, p2]) => {
                const rounds = [1, 2, 3, 4];
                const homeRounds = [];
                while (homeRounds.length < 2) {
                    const r = rounds[Math.floor(Math.random() * rounds.length)];
                    if (!homeRounds.includes(r)) homeRounds.push(r);
                }
                
                [1, 2, 3, 4].forEach(round => {
                    if (homeRounds.includes(round)) {
                        newFixtures[round].push({ home: p1, away: p2, homeScore: null, awayScore: null });
                    } else {
                        newFixtures[round].push({ home: p2, away: p1, homeScore: null, awayScore: null });
                    }
                });
            });

            Object.keys(newFixtures).forEach(round => {
                newFixtures[round].sort(() => Math.random() - 0.5);
            });

            return newFixtures;
        }

        async function loadData() {
            const statusEl = document.getElementById('syncStatus');
            
            if (USE_LOCAL_STORAGE) {
                statusEl.textContent = 'Using local storage (setup JSONBin for cloud sync)';
                const saved = localStorage.getItem('tableTennisFixtures');
                if (saved) {
                    fixtures = JSON.parse(saved);
                } else {
                    fixtures = generateFixtures();
                    localStorage.setItem('tableTennisFixtures', JSON.stringify(fixtures));
                }
                lastUpdateTime = Date.now();  // Update timestamp
                renderAll();
                return;
            }

            statusEl.textContent = 'Syncing with cloud...';
            
            try {
                const response = await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}/latest`, {
                    headers: {
                        'X-Master-Key': API_KEY
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const record = data.record;
                    
                    // Check if data has new structure (with archives)
                    if (record.currentSeason) {
                        currentSeasonName = record.currentSeason.name || 'Season 2026';
                        fixtures = record.currentSeason.fixtures;
                        archivedSeasons = record.archives || [];
                        
                        // Load players and teams if saved
                        if (record.currentSeason.players) {
                            players = record.currentSeason.players;
                        }
                        if (record.currentSeason.teams) {
                            teams = record.currentSeason.teams;
                        }
                    } else {
                        // Old structure - just fixtures
                        fixtures = record;
                        archivedSeasons = [];
                    }
                    
                    statusEl.textContent = 'Synced ‚úì';
                    lastUpdateTime = Date.now();  // Update timestamp
                } else {
                    throw new Error('Failed to load');
                }
            } catch (error) {
                console.error('Load error:', error);
                // Only generate fresh fixtures if we have nothing at all locally
                // Never overwrite cloud data on a network error
                if (!fixtures || Object.keys(fixtures).length === 0) {
                    fixtures = generateFixtures();
                    statusEl.textContent = 'New league created (not yet saved)';
                } else {
                    statusEl.textContent = '‚ö†Ô∏è Sync failed - using local data';
                    statusEl.style.color = 'rgb(239, 68, 68)';
                    setTimeout(() => { statusEl.style.color = ''; }, 5000);
                }
            }
            
            renderAll();
        }

        async function saveData() {
            if (USE_LOCAL_STORAGE) {
                localStorage.setItem('tableTennisFixtures', JSON.stringify(fixtures));
                return;
            }

            const statusEl = document.getElementById('syncStatus');
            statusEl.textContent = 'Saving...';
            
            try {
                const dataToSave = {
                    currentSeason: {
                        name: currentSeasonName,
                        fixtures: fixtures,
                        players: players,
                        teams: teams
                    },
                    archives: archivedSeasons
                };
                
                const response = await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': API_KEY
                    },
                    body: JSON.stringify(dataToSave)
                });
                
                if (response.ok) {
                    statusEl.textContent = 'Saved ‚úì';
                    setTimeout(() => {
                        statusEl.textContent = 'Synced ‚úì';
                    }, 2000);
                } else {
                    throw new Error('Failed to save');
                }
            } catch (error) {
                console.error('Save error:', error);
                statusEl.textContent = '‚ö†Ô∏è Save failed!';
                statusEl.style.color = 'rgb(239, 68, 68)';
                setTimeout(() => { statusEl.style.color = ''; }, 5000);
            }
        }

        function showPasswordModal() {
            document.getElementById('passwordModal').classList.add('active');
            document.getElementById('passwordInput').focus();
        }

        function hidePasswordModal() {
            document.getElementById('passwordModal').classList.remove('active');
            document.getElementById('passwordInput').value = '';
        }

        function submitPassword() {
            const password = document.getElementById('passwordInput').value;
            if (password === EDIT_PASSWORD) {
                isEditMode = true;
                document.getElementById('editBtn').style.display = 'none';
                document.getElementById('editStatus').style.display = 'flex';
                hidePasswordModal();
                renderAll();
            } else {
                alert('Incorrect password');
                document.getElementById('passwordInput').value = '';
            }
        }

        function disableEditMode() {
            isEditMode = false;
            document.getElementById('editBtn').style.display = 'inline-block';
            document.getElementById('editStatus').style.display = 'none';
            renderAll();
        }

        async function updateScore(round, index, type, value) {
            if (!isEditMode) {
                alert('Please enable edit mode to make changes');
                return;
            }

            const parsed = value === '' ? null : parseInt(value);
            const score = isNaN(parsed) ? null : parsed;
            if (type === 'home') {
                fixtures[round][index].homeScore = score;
            } else {
                fixtures[round][index].awayScore = score;
            }
            
            // Update league tables immediately but DON'T re-render fixtures
            // - renderFixtures() would destroy the input you're currently typing in
            renderIndividualLeague();
            renderTeamLeague();

            // Debounce the save and full re-render
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                await saveData();
                renderFixtures(); // Now safe to re-render fixtures
                saveTimeout = null;
            }, 800);
        }

        function getWinner(match) {
            if (match.homeScore === null || match.awayScore === null) return null;
            if (match.homeScore > match.awayScore) return 'home';
            if (match.awayScore > match.homeScore) return 'away';
            return null;
        }

        function isValidScore(homeScore, awayScore) {
            // Both scores must be entered
            if (homeScore === null || awayScore === null) return true; // Not invalid, just incomplete
            
            // At least one score must be 11
            if (homeScore !== 11 && awayScore !== 11) return false;
            
            // The winner must have 11
            if (homeScore === 11 && awayScore >= 11) return false;
            if (awayScore === 11 && homeScore >= 11) return false;
            
            return true;
        }

        function renderFixtures() {
            const container = document.getElementById('fixturesContent');
            container.innerHTML = '';

            Object.keys(fixtures).sort((a, b) => Number(a) - Number(b)).forEach(round => {
                const card = document.createElement('div');
                card.className = 'card';
                
                // Calculate completed matches for this round
                const totalMatches = fixtures[round].length;
                const completedMatches = fixtures[round].filter(m => {
                    return m.homeScore !== null && m.awayScore !== null && isValidScore(m.homeScore, m.awayScore);
                }).length;
                const progressPercent = (completedMatches / totalMatches * 100).toFixed(0);
                
                card.innerHTML = `
                    <div class="card-title">
                        Round ${round}
                        <span style="float: right; font-size: 0.9rem; color: ${completedMatches === totalMatches ? 'rgb(34, 197, 94)' : 'var(--accent)'};">
                            ${completedMatches}/${totalMatches} Complete
                        </span>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); height: 6px; border-radius: 3px; margin-bottom: 1rem; overflow: hidden;">
                        <div style="background: linear-gradient(90deg, rgb(34, 197, 94), rgb(42, 157, 143)); height: 100%; width: ${progressPercent}%; transition: width 0.3s ease;"></div>
                    </div>
                `;
                
                const grid = document.createElement('div');
                grid.className = 'fixtures-grid';

                fixtures[round].forEach((match, index) => {
                    // Skip matches with invalid player codes
                    if (!players[match.home] || !players[match.away]) {
                        console.warn('Invalid player codes in match:', match);
                        return;
                    }
                    
                    const winner = getWinner(match);
                    const valid = isValidScore(match.homeScore, match.awayScore);
                    const hasScores = match.homeScore !== null && match.awayScore !== null;
                    
                    // Apply filter
                    const isComplete = hasScores && valid && winner;
                    const isPending = !hasScores || !valid;
                    
                    if (fixtureFilter === 'pending' && !isPending) return;
                    if (fixtureFilter === 'completed' && !isComplete) return;
                    
                    let cardClass = 'match-card';
                    let statusText = '';
                    
                    if (hasScores && !valid) {
                        cardClass = 'match-card invalid';
                        statusText = '<div class="invalid-badge">‚ö†Ô∏è Invalid Score - Winner must have 11</div>';
                    } else if (winner) {
                        cardClass = 'match-card completed';
                        const winnerText = winner === 'home' ? `${players[match.home].name} Wins` : `${players[match.away].name} Wins`;
                        statusText = `<div class="winner-badge">${winnerText}</div>`;
                    }

                    const matchDiv = document.createElement('div');
                    matchDiv.className = cardClass;
                    matchDiv.innerHTML = `
                        <div class="round-badge">Round ${round}</div>
                        <div class="match-players">
                            <div class="player-info">
                                <div style="font-size: 0.7rem; color: var(--accent); font-weight: 700; text-transform: uppercase; margin-bottom: 0.25rem;">HOME</div>
                                <div class="player-name">${players[match.home].name}</div>
                                <div class="player-team">${teams[players[match.home].team]?.name || players[match.home].team}</div>
                            </div>
                            <div class="vs">VS</div>
                            <div class="player-info away">
                                <div style="font-size: 0.7rem; color: var(--text-dim); font-weight: 700; text-transform: uppercase; margin-bottom: 0.25rem;">AWAY</div>
                                <div class="player-name">${players[match.away].name}</div>
                                <div class="player-team">${teams[players[match.away].team]?.name || players[match.away].team}</div>
                            </div>
                        </div>
                        <div class="score-inputs">
                            <input type="number" class="score-input" min="0" max="11" 
                                   value="${match.homeScore !== null ? match.homeScore : ''}" 
                                   oninput="updateScore(${round}, ${index}, 'home', this.value)"
                                   ${!isEditMode ? 'disabled' : ''}>
                            <div>-</div>
                            <input type="number" class="score-input" min="0" max="11" 
                                   value="${match.awayScore !== null ? match.awayScore : ''}" 
                                   oninput="updateScore(${round}, ${index}, 'away', this.value)"
                                   ${!isEditMode ? 'disabled' : ''}>
                        </div>
                        ${statusText}
                    `;
                    
                    grid.appendChild(matchDiv);
                });

                card.appendChild(grid);
                // Only show round card if at least one match passed the filter
                if (grid.children.length > 0) {
                    container.appendChild(card);
                }
            });

            // Show a message if filtering hid everything
            if (container.children.length === 0) {
                container.innerHTML = '<div class="info-text" style="text-align:center; padding: 2rem;">No matches match the current filter.</div>';
            }
        }

        function calculateIndividualStats() {
            const stats = {};
            
            Object.keys(players).forEach(code => {
                stats[code] = {
                    code,
                    name: players[code].name,
                    team: players[code].team,
                    played: 0,
                    won: 0,
                    lost: 0,
                    winToNil: 0,
                    pointsFor: 0,
                    pointsAgainst: 0,
                    points: 0
                };
            });

            Object.values(fixtures).flat().forEach(match => {
                // Skip if scores aren't entered or are invalid
                if (match.homeScore === null || match.awayScore === null) return;
                if (!isValidScore(match.homeScore, match.awayScore)) return;
                
                // Skip if player codes don't exist (shouldn't happen but safety check)
                if (!stats[match.home] || !stats[match.away]) {
                    console.warn('Invalid player codes in stats:', match);
                    return;
                }
                
                stats[match.home].played++;
                stats[match.away].played++;
                stats[match.home].pointsFor += match.homeScore;
                stats[match.home].pointsAgainst += match.awayScore;
                stats[match.away].pointsFor += match.awayScore;
                stats[match.away].pointsAgainst += match.homeScore;

                if (match.homeScore > match.awayScore) {
                    stats[match.home].won++;
                    stats[match.away].lost++;
                    stats[match.home].points += match.awayScore === 0 ? 2 : 1;
                    if (match.awayScore === 0) stats[match.home].winToNil++;
                } else if (match.awayScore > match.homeScore) {
                    stats[match.away].won++;
                    stats[match.home].lost++;
                    stats[match.away].points += match.homeScore === 0 ? 2 : 1;
                    if (match.homeScore === 0) stats[match.away].winToNil++;
                }
            });

            return Object.values(stats).sort((a, b) => {
                // 1. Sort by Points (highest first)
                if (b.points !== a.points) return b.points - a.points;
                
                // 2. Sort by Points Difference (highest first)
                const aDiff = a.pointsFor - a.pointsAgainst;
                const bDiff = b.pointsFor - b.pointsAgainst;
                if (bDiff !== aDiff) return bDiff - aDiff;
                
                // 3. Sort by Points For (highest first)
                if (b.pointsFor !== a.pointsFor) return b.pointsFor - a.pointsFor;
                
                // 4. Sort by Wins to Nil (highest first)
                if (b.winToNil !== a.winToNil) return b.winToNil - a.winToNil;
                
                // 5. Sort by Name alphabetically
                return a.name.localeCompare(b.name);
            });
        }

        function renderIndividualLeague() {
            const stats = calculateIndividualStats();
            const tbody = document.getElementById('individual-table');
            tbody.innerHTML = '';

            stats.forEach((player, index) => {
                const diff = player.pointsFor - player.pointsAgainst;
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="center pos">${index + 1}</td>
                    <td class="player-cell"><span class="clickable-player" onclick="showPlayerStats('${player.code}')">${player.name}</span></td>
                    <td><span class="team-badge ${player.team === 'Team 1' ? 'team1' : 'team2'}">${teams[player.team]?.name || player.team}</span></td>
                    <td class="center">${player.played}</td>
                    <td class="center">${player.won}</td>
                    <td class="center">${player.lost}</td>
                    <td class="center">${player.winToNil}</td>
                    <td class="center">${player.pointsFor}</td>
                    <td class="center">${player.pointsAgainst}</td>
                    <td class="center ${diff > 0 ? 'positive' : diff < 0 ? 'negative' : ''}">${diff > 0 ? '+' : ''}${diff}</td>
                    <td class="center stat-highlight">${player.points}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function calculateTeamStats() {
            const individualStats = calculateIndividualStats();
            const teamStats = {};

            Object.keys(teams).forEach(teamName => {
                const teamPlayers = teams[teamName].players;
                const playerStats = individualStats.filter(p => teamPlayers.includes(p.code));

                teamStats[teamName] = {
                    name: teams[teamName].name,
                    players: teamPlayers.map(code => players[code].name).join(', '),
                    played: playerStats.reduce((sum, p) => sum + p.played, 0),
                    won: playerStats.reduce((sum, p) => sum + p.won, 0),
                    lost: playerStats.reduce((sum, p) => sum + p.lost, 0),
                    winToNil: playerStats.reduce((sum, p) => sum + p.winToNil, 0),
                    pointsFor: playerStats.reduce((sum, p) => sum + p.pointsFor, 0),
                    pointsAgainst: playerStats.reduce((sum, p) => sum + p.pointsAgainst, 0),
                    points: 0
                };
            });

            Object.values(fixtures).flat().forEach(match => {
                // Skip if scores aren't entered or are invalid
                if (match.homeScore === null || match.awayScore === null) return;
                if (!isValidScore(match.homeScore, match.awayScore)) return;
                
                const homeTeam = players[match.home].team;
                const awayTeam = players[match.away].team;

                if (match.homeScore > match.awayScore) {
                    teamStats[homeTeam].points += 1;
                } else if (match.awayScore > match.homeScore) {
                    teamStats[awayTeam].points += 1;
                }
            });

            return Object.values(teamStats).sort((a, b) => {
                // 1. Sort by Points (highest first)
                if (b.points !== a.points) return b.points - a.points;
                
                // 2. Sort by Points Difference (highest first)
                const aDiff = a.pointsFor - a.pointsAgainst;
                const bDiff = b.pointsFor - b.pointsAgainst;
                if (bDiff !== aDiff) return bDiff - aDiff;
                
                // 3. Sort by Points For (highest first)
                if (b.pointsFor !== a.pointsFor) return b.pointsFor - a.pointsFor;
                
                // 4. Sort by Wins to Nil (highest first)
                if (b.winToNil !== a.winToNil) return b.winToNil - a.winToNil;
                
                // 5. Sort by Name alphabetically
                return a.name.localeCompare(b.name);
            });
        }

        function renderTeamLeague() {
            const stats = calculateTeamStats();
            const tbody = document.getElementById('team-table');
            tbody.innerHTML = '';

            stats.forEach((team, index) => {
                const diff = team.pointsFor - team.pointsAgainst;
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="center pos">${index + 1}</td>
                    <td class="player-cell">${team.name}</td>
                    <td style="font-size: 0.75rem;">${team.players}</td>
                    <td class="center">${team.played}</td>
                    <td class="center">${team.won}</td>
                    <td class="center">${team.lost}</td>
                    <td class="center">${team.winToNil}</td>
                    <td class="center">${team.pointsFor}</td>
                    <td class="center">${team.pointsAgainst}</td>
                    <td class="center ${diff > 0 ? 'positive' : diff < 0 ? 'negative' : ''}">${diff > 0 ? '+' : ''}${diff}</td>
                    <td class="center stat-highlight">${team.points}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function renderAll() {
            document.getElementById('seasonSubtitle').textContent = currentSeasonName;
            renderFixtures();
            renderIndividualLeague();
            renderTeamLeague();
            populateH2HDropdown();
        }

        function populateH2HDropdown() {
            const select = document.getElementById('h2h-player-select');
            const currentValue = select.value;
            select.innerHTML = '<option value="">-- Choose a player --</option>';
            
            Object.keys(players).forEach(code => {
                const option = document.createElement('option');
                option.value = code;
                option.textContent = players[code].name;
                select.appendChild(option);
            });
            
            if (currentValue) select.value = currentValue;
        }

        function renderHeadToHead() {
            const selectedPlayer = document.getElementById('h2h-player-select').value;
            const content = document.getElementById('h2h-content');
            
            if (!selectedPlayer) {
                content.innerHTML = '';
                return;
            }
            
            if (!fixtures || typeof fixtures !== 'object') {
                content.innerHTML = '<div class="info-text">No fixtures available</div>';
                return;
            }
            
            // Calculate head-to-head records
            const h2hRecords = {};
            Object.keys(players).forEach(code => {
                if (code !== selectedPlayer) {
                    h2hRecords[code] = {
                        opponent: players[code].name,
                        played: 0,
                        won: 0,
                        lost: 0,
                        pointsFor: 0,
                        pointsAgainst: 0
                    };
                }
            });
            
            Object.values(fixtures).flat().forEach(match => {
                if (match.homeScore === null || match.awayScore === null) return;
                if (!isValidScore(match.homeScore, match.awayScore)) return;
                
                if (match.home === selectedPlayer) {
                    const oppCode = match.away;
                    h2hRecords[oppCode].played++;
                    h2hRecords[oppCode].pointsFor += match.homeScore;
                    h2hRecords[oppCode].pointsAgainst += match.awayScore;
                    if (match.homeScore > match.awayScore) h2hRecords[oppCode].won++;
                    else h2hRecords[oppCode].lost++;
                } else if (match.away === selectedPlayer) {
                    const oppCode = match.home;
                    h2hRecords[oppCode].played++;
                    h2hRecords[oppCode].pointsFor += match.awayScore;
                    h2hRecords[oppCode].pointsAgainst += match.homeScore;
                    if (match.awayScore > match.homeScore) h2hRecords[oppCode].won++;
                    else h2hRecords[oppCode].lost++;
                }
            });
            
            // Render table
            let html = `
                <div class="table-responsive">
                    <table>
                        <thead>
                            <tr>
                                <th>Opponent</th>
                                <th class="center">Played</th>
                                <th class="center">Won</th>
                                <th class="center">Lost</th>
                                <th class="center">PF</th>
                                <th class="center">PA</th>
                                <th class="center">Diff</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            Object.values(h2hRecords).forEach(record => {
                const diff = record.pointsFor - record.pointsAgainst;
                html += `
                    <tr>
                        <td class="player-cell">${record.opponent}</td>
                        <td class="center">${record.played}</td>
                        <td class="center">${record.won}</td>
                        <td class="center">${record.lost}</td>
                        <td class="center">${record.pointsFor}</td>
                        <td class="center">${record.pointsAgainst}</td>
                        <td class="center ${diff > 0 ? 'positive' : diff < 0 ? 'negative' : ''}">${diff > 0 ? '+' : ''}${diff}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            content.innerHTML = html;
        }

        function showSection(section, tabEl) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            // Only reset tabs inside the main nav bar, not the fixture filter buttons
            document.querySelectorAll('.tabs .tab').forEach(t => t.classList.remove('active'));
            
            document.getElementById(section).classList.add('active');
            if (tabEl) tabEl.classList.add('active');
        }

        function setFixtureFilter(filter) {
            fixtureFilter = filter;
            
            // Update button states
            document.getElementById('filter-all').classList.remove('active');
            document.getElementById('filter-pending').classList.remove('active');
            document.getElementById('filter-completed').classList.remove('active');
            document.getElementById(`filter-${filter}`).classList.add('active');
            
            renderFixtures();
        }

        loadData();

        // Auto-refresh every 30 seconds
        autoRefreshInterval = setInterval(async () => {
            if (!isEditMode && !saveTimeout) {  // Don't refresh while editing or while a save is pending
                await loadData();
            }
        }, 30000);

        // Pause auto-refresh when tab is hidden, resume + sync when it comes back
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            } else {
                // Tab is visible again - do one immediate sync then restart interval
                if (!isEditMode && !saveTimeout) {
                    loadData();
                }
                autoRefreshInterval = setInterval(async () => {
                    if (!isEditMode && !saveTimeout) {
                        await loadData();
                    }
                }, 30000);
            }
        });

        // Update "last updated" timestamp every second
        setInterval(() => {
            const elapsed = Math.floor((Date.now() - lastUpdateTime) / 1000);
            const el = document.getElementById('lastUpdated');
            if (elapsed < 60) {
                el.textContent = `Updated ${elapsed}s ago`;
            } else {
                const mins = Math.floor(elapsed / 60);
                el.textContent = `Updated ${mins}m ago`;
            }
        }, 1000);

        function closePlayerModal() {
            document.getElementById('playerModal').classList.remove('active');
        }

        function showPlayerStats(playerCode) {
            const player = players[playerCode];
            if (!player) return;

            // Calculate all stats for this player
            const matches = [];
            Object.values(fixtures).flat().forEach(match => {
                if (match.homeScore === null || match.awayScore === null) return;
                if (!isValidScore(match.homeScore, match.awayScore)) return;

                if (match.home === playerCode) {
                    matches.push({
                        opponent: players[match.away].name,
                        scoreFor: match.homeScore,
                        scoreAgainst: match.awayScore,
                        won: match.homeScore > match.awayScore
                    });
                } else if (match.away === playerCode) {
                    matches.push({
                        opponent: players[match.home].name,
                        scoreFor: match.awayScore,
                        scoreAgainst: match.homeScore,
                        won: match.awayScore > match.homeScore
                    });
                }
            });

            // Sort by most recent (matches are in order in fixtures)
            const recentMatches = matches.slice(-5).reverse();

            // Calculate win streaks
            let currentStreak = 0;
            let maxStreak = 0;
            let tempStreak = 0;
            
            matches.forEach(match => {
                if (match.won) {
                    tempStreak++;
                    maxStreak = Math.max(maxStreak, tempStreak);
                } else {
                    tempStreak = 0;
                }
            });

            // Current streak (from end backwards)
            for (let i = matches.length - 1; i >= 0; i--) {
                if (matches[i].won) currentStreak++;
                else break;
            }

            // Overall stats
            const played = matches.length;
            const won = matches.filter(m => m.won).length;
            const lost = played - won;
            const pointsFor = matches.reduce((sum, m) => sum + m.scoreFor, 0);
            const pointsAgainst = matches.reduce((sum, m) => sum + m.scoreAgainst, 0);
            const diff = pointsFor - pointsAgainst;

            // Build modal content
            let html = `
                <h2 style="font-family: 'Bebas Neue', sans-serif; font-size: 2.5rem; color: var(--primary); margin-bottom: 0.5rem;">
                    ${player.name}
                </h2>
                <div style="color: var(--text-dim); margin-bottom: 2rem; text-transform: uppercase; letter-spacing: 0.1em;">
                    ${teams[player.team]?.name || player.team}
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                    <div style="background: rgba(255, 107, 53, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--primary);">${played}</div>
                        <div style="font-size: 0.85rem; color: var(--text-dim); text-transform: uppercase;">Played</div>
                    </div>
                    <div style="background: rgba(34, 197, 94, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: rgb(34, 197, 94);">${won}</div>
                        <div style="font-size: 0.85rem; color: var(--text-dim); text-transform: uppercase;">Won</div>
                    </div>
                    <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: rgb(239, 68, 68);">${lost}</div>
                        <div style="font-size: 0.85rem; color: var(--text-dim); text-transform: uppercase;">Lost</div>
                    </div>
                    <div style="background: rgba(247, 184, 1, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent);">${diff > 0 ? '+' : ''}${diff}</div>
                        <div style="font-size: 0.85rem; color: var(--text-dim); text-transform: uppercase;">Diff</div>
                    </div>
                </div>

                <div style="margin-bottom: 2rem;">
                    <h3 style="font-size: 1.3rem; font-weight: 700; margin-bottom: 1rem; color: var(--primary);">
                        üî• Win Streaks
                    </h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div style="background: var(--bg); padding: 1rem; border-radius: 8px; border: 2px solid var(--border);">
                            <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.25rem;">Current Streak</div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: ${currentStreak > 0 ? 'rgb(34, 197, 94)' : 'var(--text)'};">
                                ${currentStreak > 0 ? currentStreak + ' wins' : 'None'}
                            </div>
                        </div>
                        <div style="background: var(--bg); padding: 1rem; border-radius: 8px; border: 2px solid var(--border);">
                            <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.25rem;">Best Streak</div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: rgb(34, 197, 94);">
                                ${maxStreak} wins
                            </div>
                        </div>
                    </div>
                </div>

                <div>
                    <h3 style="font-size: 1.3rem; font-weight: 700; margin-bottom: 1rem; color: var(--primary);">
                        üìä Recent Form (Last 5 Games)
                    </h3>
            `;

            if (recentMatches.length === 0) {
                html += `<div style="color: var(--text-dim); padding: 2rem; text-align: center;">No matches played yet</div>`;
            } else {
                html += `<div class="form-indicator">`;
                recentMatches.forEach(match => {
                    html += `
                        <div class="form-dot ${match.won ? 'win' : 'loss'}" title="${match.won ? 'Won' : 'Lost'} ${match.scoreFor}-${match.scoreAgainst} vs ${match.opponent}">
                            ${match.won ? 'W' : 'L'}
                        </div>
                    `;
                });
                html += `</div>`;

                html += `<div style="margin-top: 1.5rem;">`;
                recentMatches.forEach(match => {
                    html += `
                        <div style="background: var(--bg); padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center; border-left: 3px solid ${match.won ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)'};">
                            <span>${match.won ? '‚úì' : '‚úó'} vs ${match.opponent}</span>
                            <span style="font-weight: 700; color: ${match.won ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)'};">
                                ${match.scoreFor}-${match.scoreAgainst}
                            </span>
                        </div>
                    `;
                });
                html += `</div>`;
            }

            html += `</div>`;

            document.getElementById('playerModalContent').innerHTML = html;
            document.getElementById('playerModal').classList.add('active');
        }

        // ========== ADMIN FUNCTIONS ==========

        function unlockAdmin() {
            const password = document.getElementById('adminPasswordInput').value;
            if (password === ADMIN_PASSWORD) {
                isAdminMode = true;
                document.getElementById('adminLocked').style.display = 'none';
                document.getElementById('adminUnlocked').style.display = 'block';
                renderArchivedSeasons();
            } else {
                alert('Incorrect admin password');
                document.getElementById('adminPasswordInput').value = '';
            }
        }

        function exportBackup() {
            const backup = {
                seasonName: currentSeasonName,
                fixtures: fixtures,
                players: players,
                teams: teams,
                archivedSeasons: archivedSeasons,
                exportDate: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(backup, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `league-backup-${currentSeasonName.replace(/\s+/g, '-')}-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            alert('‚úÖ Backup downloaded successfully!');
        }

        function showArchiveModal() {
            const seasonName = prompt('Enter a name for this archived season:', currentSeasonName);
            if (!seasonName) return;
            
            if (!confirm(`Archive current season as "${seasonName}"?\n\nThis will save all results and you can view them later.`)) {
                return;
            }
            
            archiveSeason(seasonName);
        }

        async function archiveSeason(seasonName) {
            const archive = {
                name: seasonName,
                fixtures: fixtures,
                players: players,
                teams: teams,
                archivedDate: new Date().toISOString(),
                stats: {
                    individual: calculateIndividualStats(),
                    team: calculateTeamStats()
                }
            };
            
            archivedSeasons.push(archive);
            await saveArchivedSeasons();
            
            alert(`‚úÖ Season "${seasonName}" archived successfully!`);
            renderArchivedSeasons();
        }

        async function saveArchivedSeasons() {
            try {
                const data = {
                    currentSeason: {
                        name: currentSeasonName,
                        fixtures: fixtures,
                        players: players,
                        teams: teams
                    },
                    archives: archivedSeasons
                };
                
                const response = await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': API_KEY
                    },
                    body: JSON.stringify(data)
                });
                
                if (!response.ok) throw new Error('Failed to save');
            } catch (error) {
                console.error('Save error:', error);
                alert('Failed to save archives. Please try again.');
            }
        }

        function renderArchivedSeasons() {
            const container = document.getElementById('archivedSeasonsList');
            
            if (archivedSeasons.length === 0) {
                container.innerHTML = '<div class="info-text">No archived seasons yet.</div>';
                return;
            }
            
            let html = '<div style="display: grid; gap: 1rem;">';
            archivedSeasons.forEach((archive, index) => {
                const date = new Date(archive.archivedDate).toLocaleDateString();
                html += `
                    <div style="background: var(--bg); border: 2px solid var(--border); border-radius: 8px; padding: 1rem;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                            <div>
                                <div style="font-weight: 700; font-size: 1.1rem; color: var(--primary);">${archive.name}</div>
                                <div style="font-size: 0.85rem; color: var(--text-dim);">Archived: ${date}</div>
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                <button class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.85rem;" onclick="viewArchive(${index})">
                                    üëÅÔ∏è View
                                </button>
                                <button class="btn" style="padding: 0.5rem 1rem; font-size: 0.85rem; background: rgb(239, 68, 68); color: white;" onclick="deleteArchive(${index})">
                                    üóëÔ∏è Delete
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function viewArchive(index) {
            const archive = archivedSeasons[index];
            const archivePlayers = archive.players;
            const archiveTeams = archive.teams;
            const archiveFixtures = archive.fixtures;
            const date = new Date(archive.archivedDate).toLocaleDateString();

            // Recalculate individual stats from archived fixtures
            const stats = {};
            Object.keys(archivePlayers).forEach(code => {
                stats[code] = {
                    code,
                    name: archivePlayers[code].name,
                    team: archivePlayers[code].team,
                    played: 0, won: 0, lost: 0, winToNil: 0,
                    pointsFor: 0, pointsAgainst: 0, points: 0
                };
            });

            Object.values(archiveFixtures).flat().forEach(match => {
                if (match.homeScore === null || match.awayScore === null) return;
                if (!isValidScore(match.homeScore, match.awayScore)) return;
                if (!stats[match.home] || !stats[match.away]) return;

                stats[match.home].played++;
                stats[match.away].played++;
                stats[match.home].pointsFor += match.homeScore;
                stats[match.home].pointsAgainst += match.awayScore;
                stats[match.away].pointsFor += match.awayScore;
                stats[match.away].pointsAgainst += match.homeScore;

                if (match.homeScore > match.awayScore) {
                    stats[match.home].won++;
                    stats[match.away].lost++;
                    stats[match.home].points += match.awayScore === 0 ? 2 : 1;
                    if (match.awayScore === 0) stats[match.home].winToNil++;
                } else if (match.awayScore > match.homeScore) {
                    stats[match.away].won++;
                    stats[match.home].lost++;
                    stats[match.away].points += match.homeScore === 0 ? 2 : 1;
                    if (match.homeScore === 0) stats[match.away].winToNil++;
                }
            });

            const individualSorted = Object.values(stats).sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                const aDiff = a.pointsFor - a.pointsAgainst;
                const bDiff = b.pointsFor - b.pointsAgainst;
                if (bDiff !== aDiff) return bDiff - aDiff;
                if (b.pointsFor !== a.pointsFor) return b.pointsFor - a.pointsFor;
                if (b.winToNil !== a.winToNil) return b.winToNil - a.winToNil;
                return a.name.localeCompare(b.name);
            });

            // Recalculate team stats
            const teamStats = {};
            Object.keys(archiveTeams).forEach(teamKey => {
                const teamPlayers = archiveTeams[teamKey].players;
                const playerStats = individualSorted.filter(p => teamPlayers.includes(p.code));
                teamStats[teamKey] = {
                    name: archiveTeams[teamKey].name,
                    players: teamPlayers.map(code => archivePlayers[code].name).join(', '),
                    played: playerStats.reduce((s, p) => s + p.played, 0),
                    won: playerStats.reduce((s, p) => s + p.won, 0),
                    lost: playerStats.reduce((s, p) => s + p.lost, 0),
                    winToNil: playerStats.reduce((s, p) => s + p.winToNil, 0),
                    pointsFor: playerStats.reduce((s, p) => s + p.pointsFor, 0),
                    pointsAgainst: playerStats.reduce((s, p) => s + p.pointsAgainst, 0),
                    points: 0
                };
            });

            Object.values(archiveFixtures).flat().forEach(match => {
                if (match.homeScore === null || match.awayScore === null) return;
                if (!isValidScore(match.homeScore, match.awayScore)) return;
                if (!archivePlayers[match.home] || !archivePlayers[match.away]) return;
                const homeTeam = archivePlayers[match.home].team;
                const awayTeam = archivePlayers[match.away].team;
                if (match.homeScore > match.awayScore) teamStats[homeTeam].points += 1;
                else if (match.awayScore > match.homeScore) teamStats[awayTeam].points += 1;
            });

            const teamSorted = Object.values(teamStats).sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                const aDiff = a.pointsFor - a.pointsAgainst;
                const bDiff = b.pointsFor - b.pointsAgainst;
                if (bDiff !== aDiff) return bDiff - aDiff;
                if (b.pointsFor !== a.pointsFor) return b.pointsFor - a.pointsFor;
                return a.name.localeCompare(b.name);
            });

            // Build HTML
            let html = `
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div>
                        <h2 style="font-family: 'Bebas Neue', sans-serif; font-size: 2.5rem; color: var(--primary); margin-bottom: 0.25rem;">
                            ${archive.name}
                        </h2>
                        <div style="color: var(--text-dim); margin-bottom: 1.5rem; font-size: 0.85rem;">
                            Archived: ${date}
                        </div>
                    </div>
                    <button class="btn" style="background: rgb(239, 68, 68); color: white; padding: 0.6rem 1rem; font-size: 0.8rem; white-space: nowrap;" onclick="printArchive(${index})">
                        üñ®Ô∏è Print / Save PDF
                    </button>
                </div>
            `;

            // Team League Table
            html += `
                <h3 style="color: var(--primary); font-size: 1.3rem; margin-bottom: 0.75rem;">üèÜ Team Standings</h3>
                <div class="table-responsive" style="margin-bottom: 1.5rem;">
                    <table>
                        <thead>
                            <tr>
                                <th class="center">Pos</th>
                                <th>Team</th>
                                <th>Players</th>
                                <th class="center">P</th>
                                <th class="center">W</th>
                                <th class="center">L</th>
                                <th class="center">PF</th>
                                <th class="center">PA</th>
                                <th class="center">Diff</th>
                                <th class="center">Pts</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            teamSorted.forEach((team, i) => {
                const diff = team.pointsFor - team.pointsAgainst;
                html += `
                    <tr>
                        <td class="center pos">${i + 1}</td>
                        <td class="player-cell">${team.name}</td>
                        <td style="font-size: 0.75rem;">${team.players}</td>
                        <td class="center">${team.played}</td>
                        <td class="center">${team.won}</td>
                        <td class="center">${team.lost}</td>
                        <td class="center">${team.pointsFor}</td>
                        <td class="center">${team.pointsAgainst}</td>
                        <td class="center ${diff > 0 ? 'positive' : diff < 0 ? 'negative' : ''}">${diff > 0 ? '+' : ''}${diff}</td>
                        <td class="center stat-highlight">${team.points}</td>
                    </tr>
                `;
            });
            html += `</tbody></table></div>`;

            // Individual League Table
            html += `
                <h3 style="color: var(--primary); font-size: 1.3rem; margin-bottom: 0.75rem;">üèÖ Individual Standings</h3>
                <div class="table-responsive" style="margin-bottom: 1.5rem;">
                    <table>
                        <thead>
                            <tr>
                                <th class="center">Pos</th>
                                <th>Player</th>
                                <th>Team</th>
                                <th class="center">P</th>
                                <th class="center">W</th>
                                <th class="center">L</th>
                                <th class="center">W-N</th>
                                <th class="center">PF</th>
                                <th class="center">PA</th>
                                <th class="center">Diff</th>
                                <th class="center">Pts</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            individualSorted.forEach((player, i) => {
                const diff = player.pointsFor - player.pointsAgainst;
                html += `
                    <tr>
                        <td class="center pos">${i + 1}</td>
                        <td class="player-cell">${player.name}</td>
                        <td><span class="team-badge ${player.team === 'Team 1' ? 'team1' : 'team2'}">${archiveTeams[player.team]?.name || player.team}</span></td>
                        <td class="center">${player.played}</td>
                        <td class="center">${player.won}</td>
                        <td class="center">${player.lost}</td>
                        <td class="center">${player.winToNil}</td>
                        <td class="center">${player.pointsFor}</td>
                        <td class="center">${player.pointsAgainst}</td>
                        <td class="center ${diff > 0 ? 'positive' : diff < 0 ? 'negative' : ''}">${diff > 0 ? '+' : ''}${diff}</td>
                        <td class="center stat-highlight">${player.points}</td>
                    </tr>
                `;
            });
            html += `</tbody></table></div>`;

            // Fixtures
            html += `<h3 style="color: var(--primary); font-size: 1.3rem; margin-bottom: 0.75rem;">üìã Fixtures</h3>`;

            Object.keys(archiveFixtures).sort((a, b) => Number(a) - Number(b)).forEach(round => {
                const matches = archiveFixtures[round];
                const completedCount = matches.filter(m => m.homeScore !== null && m.awayScore !== null && isValidScore(m.homeScore, m.awayScore)).length;

                html += `<div style="margin-bottom: 1rem;">
                    <div style="font-weight: 700; color: var(--accent); margin-bottom: 0.5rem; font-size: 1rem;">
                        Round ${round} <span style="color: var(--text-dim); font-weight: 400; font-size: 0.85rem;">(${completedCount}/${matches.length} played)</span>
                    </div>`;

                matches.forEach(match => {
                    if (!archivePlayers[match.home] || !archivePlayers[match.away]) return;
                    const hasScores = match.homeScore !== null && match.awayScore !== null;
                    const valid = isValidScore(match.homeScore, match.awayScore);
                    const completed = hasScores && valid;
                    let borderColor = 'var(--border)';
                    if (completed) borderColor = 'rgb(34, 197, 94)';

                    html += `
                        <div style="display: flex; justify-content: space-between; align-items: center; background: var(--bg); padding: 0.6rem 0.75rem; border-radius: 6px; margin-bottom: 0.35rem; border-left: 3px solid ${borderColor};">
                            <span style="flex: 1; text-align: right; padding-right: 0.75rem;">
                                <strong>${archivePlayers[match.home].name}</strong>
                                <span style="font-size: 0.7rem; color: var(--accent); margin-left: 0.3rem;">H</span>
                            </span>
                            <span style="font-weight: 700; color: ${completed ? 'var(--accent)' : 'var(--text-dim)'}; min-width: 50px; text-align: center;">
                                ${hasScores ? match.homeScore + ' - ' + match.awayScore : '‚Äî'}
                            </span>
                            <span style="flex: 1; padding-left: 0.75rem;">
                                <span style="font-size: 0.7rem; color: var(--text-dim); margin-right: 0.3rem;">A</span>
                                <strong>${archivePlayers[match.away].name}</strong>
                            </span>
                        </div>
                    `;
                });
                html += `</div>`;
            });

            document.getElementById('archiveModalContent').innerHTML = html;
            document.getElementById('archiveModal').classList.add('active');
        }

        function closeArchiveModal() {
            document.getElementById('archiveModal').classList.remove('active');
        }

        function printArchive(index) {
            const archive = archivedSeasons[index];
            const archivePlayers = archive.players;
            const archiveTeams = archive.teams;
            const archiveFixtures = archive.fixtures;
            const date = new Date(archive.archivedDate).toLocaleDateString();

            // Recalculate stats
            const stats = {};
            Object.keys(archivePlayers).forEach(code => {
                stats[code] = {
                    code, name: archivePlayers[code].name, team: archivePlayers[code].team,
                    played: 0, won: 0, lost: 0, winToNil: 0,
                    pointsFor: 0, pointsAgainst: 0, points: 0
                };
            });
            Object.values(archiveFixtures).flat().forEach(match => {
                if (match.homeScore === null || match.awayScore === null) return;
                if (!isValidScore(match.homeScore, match.awayScore)) return;
                if (!stats[match.home] || !stats[match.away]) return;
                stats[match.home].played++; stats[match.away].played++;
                stats[match.home].pointsFor += match.homeScore;
                stats[match.home].pointsAgainst += match.awayScore;
                stats[match.away].pointsFor += match.awayScore;
                stats[match.away].pointsAgainst += match.homeScore;
                if (match.homeScore > match.awayScore) {
                    stats[match.home].won++; stats[match.away].lost++;
                    stats[match.home].points += match.awayScore === 0 ? 2 : 1;
                    if (match.awayScore === 0) stats[match.home].winToNil++;
                } else if (match.awayScore > match.homeScore) {
                    stats[match.away].won++; stats[match.home].lost++;
                    stats[match.away].points += match.homeScore === 0 ? 2 : 1;
                    if (match.homeScore === 0) stats[match.away].winToNil++;
                }
            });
            const individualSorted = Object.values(stats).sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                const aDiff = a.pointsFor - a.pointsAgainst, bDiff = b.pointsFor - b.pointsAgainst;
                if (bDiff !== aDiff) return bDiff - aDiff;
                if (b.pointsFor !== a.pointsFor) return b.pointsFor - a.pointsFor;
                if (b.winToNil !== a.winToNil) return b.winToNil - a.winToNil;
                return a.name.localeCompare(b.name);
            });
            const teamStats = {};
            Object.keys(archiveTeams).forEach(tk => {
                const tp = archiveTeams[tk].players;
                const ps = individualSorted.filter(p => tp.includes(p.code));
                teamStats[tk] = {
                    name: archiveTeams[tk].name,
                    players: tp.map(c => archivePlayers[c].name).join(', '),
                    played: ps.reduce((s,p) => s+p.played,0),
                    won: ps.reduce((s,p) => s+p.won,0),
                    lost: ps.reduce((s,p) => s+p.lost,0),
                    winToNil: ps.reduce((s,p) => s+p.winToNil,0),
                    pointsFor: ps.reduce((s,p) => s+p.pointsFor,0),
                    pointsAgainst: ps.reduce((s,p) => s+p.pointsAgainst,0),
                    points: 0
                };
            });
            Object.values(archiveFixtures).flat().forEach(match => {
                if (match.homeScore === null || match.awayScore === null) return;
                if (!isValidScore(match.homeScore, match.awayScore)) return;
                if (!archivePlayers[match.home] || !archivePlayers[match.away]) return;
                const ht = archivePlayers[match.home].team, at = archivePlayers[match.away].team;
                if (match.homeScore > match.awayScore) teamStats[ht].points++;
                else if (match.awayScore > match.homeScore) teamStats[at].points++;
            });
            const teamSorted = Object.values(teamStats).sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                const aDiff = a.pointsFor - a.pointsAgainst, bDiff = b.pointsFor - b.pointsAgainst;
                if (bDiff !== aDiff) return bDiff - aDiff;
                if (b.pointsFor !== a.pointsFor) return b.pointsFor - a.pointsFor;
                return a.name.localeCompare(b.name);
            });

            // Build team rows
            let teamRows = '';
            teamSorted.forEach((t, i) => {
                const diff = t.pointsFor - t.pointsAgainst;
                teamRows += `<tr>
                    <td>${i+1}</td>
                    <td>${t.name}</td>
                    <td>${t.players}</td>
                    <td>${t.played}</td><td>${t.won}</td><td>${t.lost}</td>
                    <td>${t.pointsFor}</td><td>${t.pointsAgainst}</td>
                    <td class="${diff > 0 ? 'pos' : diff < 0 ? 'neg' : ''}">${diff > 0 ? '+' : ''}${diff}</td>
                    <td class="pts">${t.points}</td>
                </tr>`;
            });

            // Build individual rows
            let indivRows = '';
            individualSorted.forEach((p, i) => {
                const diff = p.pointsFor - p.pointsAgainst;
                const teamName = archiveTeams[p.team]?.name || p.team;
                indivRows += `<tr>
                    <td>${i+1}</td>
                    <td>${p.name}</td>
                    <td class="${p.team === 'Team 1' ? 'team1' : 'team2'}">${teamName}</td>
                    <td>${p.played}</td><td>${p.won}</td><td>${p.lost}</td><td>${p.winToNil}</td>
                    <td>${p.pointsFor}</td><td>${p.pointsAgainst}</td>
                    <td class="${diff > 0 ? 'pos' : diff < 0 ? 'neg' : ''}">${diff > 0 ? '+' : ''}${diff}</td>
                    <td class="pts">${p.points}</td>
                </tr>`;
            });

            // Build fixture rounds
            let fixtureHTML = '';
            Object.keys(archiveFixtures).sort((a,b) => Number(a)-Number(b)).forEach(round => {
                const matches = archiveFixtures[round];
                const completedCount = matches.filter(m => m.homeScore !== null && m.awayScore !== null && isValidScore(m.homeScore, m.awayScore)).length;
                fixtureHTML += `<h3>Round ${round} <span style="font-weight:400; color:#888; font-size:0.85em;">(${completedCount}/${matches.length} played)</span></h3>
                <table class="fixtures-table">
                    <thead><tr><th>Home</th><th>Score</th><th>Away</th></tr></thead>
                    <tbody>`;
                matches.forEach(match => {
                    if (!archivePlayers[match.home] || !archivePlayers[match.away]) return;
                    const hasScores = match.homeScore !== null && match.awayScore !== null;
                    const valid = isValidScore(match.homeScore, match.awayScore);
                    const completed = hasScores && valid;
                    fixtureHTML += `<tr class="${completed ? 'completed' : ''}">
                        <td class="home-player">${archivePlayers[match.home].name} <span class="label">H</span></td>
                        <td class="score">${completed ? match.homeScore + ' - ' + match.awayScore : '-'}</td>
                        <td class="away-player"><span class="label">A</span> ${archivePlayers[match.away].name}</td>
                    </tr>`;
                });
                fixtureHTML += `</tbody></table>`;
            });

            // Open print window
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${archive.name} - Season Report</title>
                    <style>
                        * { margin: 0; padding: 0; box-sizing: border-box; }
                        body { font-family: Arial, sans-serif; color: #222; padding: 20px; }
                        .header { text-align: center; margin-bottom: 24px; border-bottom: 3px solid #FF6B35; padding-bottom: 12px; }
                        .header h1 { font-size: 28px; color: #FF6B35; margin-bottom: 4px; }
                        .header p { color: #666; font-size: 13px; }
                        h2 { color: #FF6B35; font-size: 18px; margin: 22px 0 10px 0; border-bottom: 2px solid #eee; padding-bottom: 4px; }
                        h3 { color: #333; font-size: 15px; margin: 16px 0 6px 0; }
                        table { width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 13px; }
                        th { background: #004E89; color: white; padding: 7px 6px; text-align: center; font-size: 11px; text-transform: uppercase; }
                        th:first-child, th:nth-child(2) { text-align: left; }
                        td { padding: 5px 6px; text-align: center; border-bottom: 1px solid #eee; }
                        td:first-child, td:nth-child(2) { text-align: left; }
                        tr:nth-child(even) { background: #f9f9f9; }
                        .pts { font-weight: 700; color: #FF6B35; }
                        .pos { color: #2A9D8F; font-weight: 600; }
                        .neg { color: #E76F51; font-weight: 600; }
                        .team1 { color: #2A9D8F; font-weight: 600; }
                        .team2 { color: #E76F51; font-weight: 600; }
                        .fixtures-table th { background: #2D3561; }
                        .fixtures-table .home-player { text-align: right; padding-right: 10px; }
                        .fixtures-table .away-player { text-align: left; padding-left: 10px; }
                        .fixtures-table .score { font-weight: 700; color: #FF6B35; width: 60px; }
                        .fixtures-table .completed { background: #eaf7f0; }
                        .label { display: inline-block; font-size: 9px; font-weight: 700; padding: 1px 4px; border-radius: 3px; background: #eee; color: #666; margin: 0 4px; }
                        .footer { margin-top: 30px; text-align: center; color: #aaa; font-size: 11px; border-top: 1px solid #ddd; padding-top: 10px; }

                        @media print {
                            body { padding: 0; }
                            h2 { page-break-before: auto; }
                            table { page-break-inside: avoid; }
                            .no-print { display: none; }
                        }
                    </style>
                </head>
                <body>
                    <div class="no-print" style="text-align:center; margin-bottom: 20px;">
                        <button onclick="window.print()" style="background:#FF6B35; color:white; border:none; padding:10px 28px; border-radius:6px; font-size:15px; cursor:pointer; font-weight:600;">
                            Print / Save as PDF
                        </button>
                    </div>

                    <div class="header">
                        <h1>${archive.name.toUpperCase()}</h1>
                        <p>Table Tennis League &nbsp;|&nbsp; Archived: ${date}</p>
                    </div>

                    <h2>Team Standings</h2>
                    <table>
                        <thead><tr>
                            <th>Pos</th><th>Team</th><th>Players</th>
                            <th>P</th><th>W</th><th>L</th>
                            <th>PF</th><th>PA</th><th>Diff</th><th>Pts</th>
                        </tr></thead>
                        <tbody>${teamRows}</tbody>
                    </table>

                    <h2>Individual Standings</h2>
                    <table>
                        <thead><tr>
                            <th>Pos</th><th>Player</th><th>Team</th>
                            <th>P</th><th>W</th><th>L</th><th>W-N</th>
                            <th>PF</th><th>PA</th><th>Diff</th><th>Pts</th>
                        </tr></thead>
                        <tbody>${indivRows}</tbody>
                    </table>

                    <h2>Fixtures</h2>
                    ${fixtureHTML}

                    <div class="footer">
                        ${archive.name} &nbsp;|&nbsp; Table Tennis League &nbsp;|&nbsp; Generated ${new Date().toLocaleDateString()}
                    </div>
                </body>
                </html>
            `);
            printWindow.document.close();
        }

        async function deleteArchive(index) {
            const archive = archivedSeasons[index];
            if (!confirm(`‚ö†Ô∏è Delete archived season "${archive.name}"?\n\nThis action cannot be undone!`)) {
                return;
            }
            
            archivedSeasons.splice(index, 1);
            await saveArchivedSeasons();
            renderArchivedSeasons();
            alert('‚úÖ Archived season deleted');
        }

        async function resetCurrentSeason() {
            if (!confirm('‚ö†Ô∏è Reset current season?\n\nThis will clear ALL scores but keep the fixtures.\n\nThis action cannot be undone!')) {
                return;
            }
            
            if (!confirm('Are you absolutely sure? This will erase all match results!')) {
                return;
            }
            
            // Clear all scores
            Object.keys(fixtures).forEach(round => {
                fixtures[round].forEach(match => {
                    match.homeScore = null;
                    match.awayScore = null;
                });
            });
            
            await saveData();
            await loadData();
            alert('‚úÖ Season reset! All scores cleared.');
        }

        function showNewSeasonModal() {
            if (!confirm('‚ö†Ô∏è Start a new season?\n\nThis will archive the current season and create a fresh league.\n\nContinue?')) {
                return;
            }
            
            // First archive the current season
            const archiveName = prompt('Name the current season for archiving:', currentSeasonName);
            if (!archiveName) return;
            
            archiveSeason(archiveName).then(() => {
                // Now show new season wizard
                startNewSeasonWizard();
            });
        }

        async function startNewSeasonWizard() {
            // Step 1: Season Name
            const seasonName = prompt('Enter new season name:', 'Season 2027');
            if (!seasonName) return;
            
            // Step 2: Number of players
            const numPlayers = prompt('How many players total? (Must be even: 4, 6, 8, 10, or 12)', '8');
            const playerCount = parseInt(numPlayers);
            
            if (![4, 6, 8, 10, 12].includes(playerCount)) {
                alert('Invalid number of players. Must be 4, 6, 8, 10, or 12.');
                return;
            }
            
            // Step 3: Number of rounds
            const numRounds = prompt('How many rounds? (2, 4, or 6)', '4');
            const roundCount = parseInt(numRounds);
            
            if (![2, 4, 6].includes(roundCount)) {
                alert('Invalid number of rounds. Must be 2, 4, or 6.');
                return;
            }
            
            // Step 4: Team names
            const team1Name = prompt('Enter Team 1 name:', 'Team 1');
            if (!team1Name) return;
            
            const team2Name = prompt('Enter Team 2 name:', 'Team 2');
            if (!team2Name) return;
            
            // Step 5: Player names
            const playersPerTeam = playerCount / 2;
            const newPlayers = {};
            const codes = 'ABCDEFGHIJKL'.split('');
            
            alert(`Now enter ${playersPerTeam} player names for ${team1Name}`);
            
            // Team 1 players
            for (let i = 0; i < playersPerTeam; i++) {
                const name = prompt(`${team1Name} - Player ${i + 1} name:`, `Player ${i + 1}`);
                if (!name) return;
                newPlayers[codes[i]] = { name: name, team: 'Team 1' };
            }
            
            alert(`Now enter ${playersPerTeam} player names for ${team2Name}`);
            
            // Team 2 players
            for (let i = 0; i < playersPerTeam; i++) {
                const name = prompt(`${team2Name} - Player ${i + 1} name:`, `Player ${playersPerTeam + i + 1}`);
                if (!name) return;
                newPlayers[codes[playersPerTeam + i]] = { name: name, team: 'Team 2' };
            }
            
            // Confirm before creating
            const playerNames = Object.values(newPlayers).map(p => p.name).join(', ');
            if (!confirm(`Create new season "${seasonName}"?\n\n${playerCount} players: ${playerNames}\n${roundCount} rounds\n\nGenerate fixtures now?`)) {
                return;
            }
            
            // Update season
            currentSeasonName = seasonName;
            players = newPlayers;
            
            const team1Players = codes.slice(0, playersPerTeam);
            const team2Players = codes.slice(playersPerTeam, playerCount);
            
            teams = {
                'Team 1': { name: team1Name, players: team1Players },
                'Team 2': { name: team2Name, players: team2Players }
            };
            
            // Generate new fixtures based on rounds
            fixtures = generateFixturesWithRounds(roundCount);
            
            console.log('New season created:', { currentSeasonName, players, teams, fixtures });
            
            // Disable auto-refresh temporarily
            clearInterval(autoRefreshInterval);
            
            await saveData();
            
            // Wait a moment for save to complete
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            alert(`‚úÖ New season "${seasonName}" created!\n\n${playerCount} players, ${roundCount} rounds\nFixtures generated!`);
            
            // Re-render everything
            renderAll();
            renderHeadToHead();
            
            // Re-enable auto-refresh
            autoRefreshInterval = setInterval(async () => {
                if (!isEditMode && !saveTimeout) {
                    await loadData();
                }
            }, 30000);
        }

        function generateFixturesWithRounds(numRounds) {
            const allMatchups = [];
            const playerCodes = Object.keys(players);
            
            // Get all unique pairings
            for (let i = 0; i < playerCodes.length; i++) {
                for (let j = i + 1; j < playerCodes.length; j++) {
                    allMatchups.push([playerCodes[i], playerCodes[j]]);
                }
            }

            const newFixtures = {};
            for (let r = 1; r <= numRounds; r++) {
                newFixtures[r] = [];
            }
            
            // For each matchup, assign rounds for home/away
            allMatchups.forEach(([p1, p2]) => {
                const rounds = [];
                for (let r = 1; r <= numRounds; r++) {
                    rounds.push(r);
                }
                
                // Shuffle and split home/away
                rounds.sort(() => Math.random() - 0.5);
                const homeRounds = rounds.slice(0, numRounds / 2);
                
                rounds.forEach(round => {
                    if (homeRounds.includes(round)) {
                        newFixtures[round].push({ home: p1, away: p2, homeScore: null, awayScore: null });
                    } else {
                        newFixtures[round].push({ home: p2, away: p1, homeScore: null, awayScore: null });
                    }
                });
            });

            // Shuffle each round
            Object.keys(newFixtures).forEach(round => {
                newFixtures[round].sort(() => Math.random() - 0.5);
            });

            return newFixtures;
        }
    </script>
</body>
</html>